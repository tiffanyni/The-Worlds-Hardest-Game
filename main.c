#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
#include "images/garbage.h"
#include "images/start.h"
#include "images/end.h"
#include "images/player.h"

enum gba_state {
  START,
  PLAY,
  WIN,
};

struct Player p = {22, 132, 10, 10};
struct Enemy e1 = {50, 10, 12, 12, 4, 1};
struct Enemy e2 = {80, 140, 12, 12, 2, 0};
struct Enemy e3 = {110, 10, 12, 12, 4, 1};
struct Enemy e4 = {140, 140, 12, 12, 3, 0};
struct Enemy e5 = {170, 10, 12, 12, 2, 0};
struct Goal g = {200, 20, 25, 25};
struct Enemy *enemyArr[5] = {&e1, &e2, &e3, &e4, &e5};
int numEnemies = 5;
int enemyInitialPos[5][2] = {
  {50, 10},
  {80, 140},
  {110, 10},
  {140, 140},
  {170, 10},
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  //keep track of fail count
  int fails = 0;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        waitForVBlank();
        //initiate everything
        fails = 0;
        p.xPos = 22;
        p.yPos = 132;
        for (int i = 0; i < numEnemies; i++) {
          enemyArr[i]->xPos = enemyInitialPos[i][0];
          enemyArr[i]->yPos = enemyInitialPos[i][1];
        }

        drawFullScreenImageDMA(start);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
        }
        break;
      case PLAY:
        waitForVBlank();
        fillScreenDMA(BACKGROUNDCOLOR);
        drawRectDMA(120, 10, 25, 25, GOALCOLOR); //bottom left green
        drawRectDMA(g.yPos, g.xPos, g.width, g.height, GOALCOLOR); //upper right green (GOAL)
        //drawRectDMA(p.yPos, p.xPos, p.width, p.height, RED); //initialize player (red dot)
        drawImageDMA(p.yPos, p.xPos, 10, 10, player);
        //initialize the enemies 
        for (int i = 0; i < numEnemies; i++) {
          drawRectDMA((*enemyArr[i]).yPos, (*enemyArr[i]).xPos, (*enemyArr[i]).width, (*enemyArr[i]).height, BLUE);
        }

        //display fail score
        drawString(150, 190, "Fails:", BLACK);
        int firstDigit = fails % 10;
        
        if (fails > 9) {
          int secondDigit = (fails / 10);
          drawChar(150, 225, secondDigit + 48, BLACK);
        }
          drawChar(150, 231, firstDigit + 48, BLACK);

        //check if backspace is pressed at anytime --> return to home screen
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
        }

        //control player movements
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          if (p.yPos < 145) {
            p.yPos++;
          }
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          if (p.yPos > 13) {
            p.yPos--;
          }
        }

        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          if (p.xPos > 5) {
            p.xPos--;
          }
        }

        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          if (p.xPos < 225) {
            p.xPos++;
          }
        }

        //check if need to adjust enemy movement directions, then update position
        for (int i = 0; i < numEnemies; i++) {
          if ((*enemyArr[i]).yPos <= 13) { //before was 9
            (*enemyArr[i]).movingUp = 0;
          }
          else if ((*enemyArr[i]).yPos >= 145) {
            (*enemyArr[i]).movingUp = 1;
          }
          (*enemyArr[i]).yPos = (*enemyArr[i]).movingUp ? (*enemyArr[i]).yPos - (*enemyArr[i]).speed :(*enemyArr[i]).yPos + (*enemyArr[i]).speed;
        }

        //implement collision
        for (int i = 0; i < numEnemies; i++) {
          if ((p.xPos < (*enemyArr[i]).xPos + (*enemyArr[i]).width) && (p.xPos + p.width > (*enemyArr[i]).xPos) && (p.yPos < (*enemyArr[i]).yPos + (*enemyArr[i]).height) && (p.yPos + p.height > (*enemyArr[i]).yPos)) {
            fails++;
            p.xPos = 22;
            p.yPos = 132;
          }
        }

        //implement touches goal
        if ((p.xPos < g.xPos + g.width) && (p.xPos + p.width > g.xPos) && (p.yPos < g.yPos + g.height) && (p.yPos + p.height > g.yPos)) {
          state = WIN;
        }
        break;
      case WIN:
        waitForVBlank();
        //fillScreenDMA(RED);
        drawFullScreenImageDMA(end);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
        }
        break;
    }
    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}